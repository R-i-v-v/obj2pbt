from __future__ import division
from re import findall
from os import remove
from base64 import b64decode
from os.path import splitext, isabs
from pathlib import Path, PurePath
import tkinter as tk
from tkinter import filedialog, ttk
from random import randrange
import ctypes
import numpy as np
from uuid import uuid4
from scipy.spatial.transform import Rotation as R
from PIL import Image
from math import floor

# program headed by Rivvnik#1111
np.set_printoptions(16)
anti_conflict, root = [], tk.Tk()
myappid = u'mycompany.myproduct.subproduct.version'  # arbitrary string
ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)  # set taskbar icon
root.title('obj2pbt')  # set window title
root.resizable(width=False, height=False)  # prevent resizing
progress_bar = ttk.Progressbar(root, orient='horizontal', length=230, mode='determinate', value=0)

# RIDICULOUS code block for making the icon work with --onefile
# this massive string below is the program's icon as a Base64 string.
icon_in_base_64 = """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"""
icon_data = b64decode(icon_in_base_64)
temp_icon_file = 'temp_icon.ico'
icon_file = open(temp_icon_file, 'wb')
icon_file.write(icon_data)
icon_file.close()
root.wm_iconbitmap(temp_icon_file)
remove(temp_icon_file)

# pbt generator courtesy of Aphrim#1337
class Object:
    def __init__(self, name, position, rotation, scale, parent_id, mesh_id, color):
        self.name = name
        self.position = position
        self.rotation = rotation
        self.scale = scale
        self.parent_id = parent_id
        self.mesh_id = mesh_id
        self.id = generate_id()
        self.color = color

    def generate_pbt_part(self):
        return f"""Objects {{
                    Id: {self.id}
                    Name: "{self.name}"
                    Transform {{
                    Location {{
                        X: {self.position[0]}
                        Y: {self.position[1]}
                        Z: {self.position[2]}
                    }}
                    Rotation {{
                        Pitch: {self.rotation[1]}
                        Yaw: {self.rotation[2]}
                        Roll: {self.rotation[0]}
                    }}
                    Scale {{
                        X: {self.scale[0]}
                        Y: {self.scale[1]}
                        Z: {self.scale[2]}
                    }}
                    }}
                    ParentId: {self.parent_id}
                    UnregisteredParameters {{
                        Overrides {{
                            Name: "ma:Shared_BaseMaterial:color"
                            Color {{
                                R: {min(1, self.color[0])}
                                G: {min(1, self.color[1])}
                                B: {min(1, self.color[2])}
                            }}
                        }}
                        Overrides {{
                            Name: "ma:Shared_BaseMaterial:id"
                            AssetReference {{
                                Id: 6942069420
                            }}
                        }}
                    }}
                    Collidable_v2 {{
                    Value: "mc:ecollisionsetting:inheritfromparent"
                    }}
                    Visible_v2 {{
                    Value: "mc:evisibilitysetting:inheritfromparent"
                    }}
                    CameraCollidable {{
                    Value: "mc:ecollisionsetting:inheritfromparent"
                    }}
                    EditorIndicatorVisibility {{
                    Value: "mc:eindicatorvisibility:visiblewhenselected"
                    }}
                    CoreMesh {{
                    MeshAsset {{
                        Id: {self.mesh_id}
                    }}
                    Teams {{
                        IsTeamCollisionEnabled: true
                        IsEnemyCollisionEnabled: true
                    }}
                    StaticMesh {{
                        Physics {{
                        Mass: 100
                        LinearDamping: 0.01
                        }}
                        BoundsScale: 1
                    }}
                    }}
                }}\n      """


class Folder:
    def __init__(self, root, name):
        self.id = generate_id()
        self.children = []
        self.root = root
        self.name = name

    def add_child(self, name, mesh_name, position, rotation, scale, parent_id, color):
        mesh_to_add = Object(name, position, rotation, scale, parent_id, self.root.get_mesh_id_for_name(mesh_name), color)

        if mesh_to_add.parent_id is None:
            mesh_to_add.parent_id = self.id

        if mesh_to_add.position is None:
            mesh_to_add.position = [0, 0, 0]

        if mesh_to_add.rotation is None:
            mesh_to_add.rotation = [0, 0, 0]

        if mesh_to_add.scale is None:
            mesh_to_add.scale = [1, 1, 1]

        self.children.append(mesh_to_add)
        return mesh_to_add

    def children_to_string(self):
        children_string = ""
        for object in self.children:
            children_string += f"ChildIds: {object.id}\n        "
        return children_string

    def generate_pbt_part(self):
        this_string = f"""
                Objects {{
                    Id: {self.id}
                    Name: "{self.name}"
                    Transform {{
                        Location {{
                        }}
                        Rotation {{
                        }}
                        Scale {{
                            X: {1}
                            Y: {1}
                            Z: {1}
                        }}
                    }}
                    ParentId: {self.root.root_id}
                    {self.children_to_string()}
                    Collidable_v2 {{
                    Value: "mc:ecollisionsetting:inheritfromparent"
                    }}
                    Visible_v2 {{
                    Value: "mc:evisibilitysetting:inheritfromparent"
                    }}
                    CameraCollidable {{
                    Value: "mc:ecollisionsetting:inheritfromparent"
                    }}
                    EditorIndicatorVisibility {{
                    Value: "mc:eindicatorvisibility:visiblewhenselected"
                    }}
                    Folder {{
                        IsFilePartition: true
                    }}
                }}\n      """
        children_strings = ""
        for object in self.children:
            children_strings += object.generate_pbt_part()

        return this_string + children_strings


class PBT:
    def __init__(self, name):
        self.template_name = name
        self.template_id = generate_id()
        self.root_id = generate_id()
        self.objects = []
        self.meshes_by_id = []

    def get_mesh_id_for_name(self, mesh_name):
        for mesh in self.meshes_by_id:
            if mesh['name'] == mesh_name:
                return mesh['id']
        new_mesh = {"id": generate_id(), "name": mesh_name}
        self.meshes_by_id.append(new_mesh)
        return new_mesh['id']

    def add_folder(self, name):
        new_folder = Folder(self, name)
        self.objects.append(new_folder)
        return new_folder

    def children_to_string(self):
        children_string = ""
        for object in self.objects:
            children_string += f"ChildIds: {object.id}\n        "
        return children_string

    def all_objects_pbt(self):
        all_objects_string = ""

        for object in self.objects:
            object_string = object.generate_pbt_part()
            all_objects_string += object_string
        return all_objects_string

    def object_assets_pbt(self):
        assets_string = ""
        for mesh in self.meshes_by_id:
            mesh_asset_string = f"""Assets {{
      Id: {mesh['id']}
      Name: "{mesh['name']}"
      PlatformAssetType: 1
      PrimaryAsset {{
        AssetType: "StaticMeshAssetRef"
        AssetId: "{mesh['name']}"
      }}
    }}"""
            assets_string += mesh_asset_string
        return assets_string

    def generate_pbt(self):
        pbt = f"""Assets {{
  Id: {self.template_id}
  Name: "{self.template_name}"
  PlatformAssetType: 5
  TemplateAsset {{
    ObjectBlock {{
      RootId: {self.root_id}
      Objects {{
        Id: {self.root_id}
        Name: "Folder"
        Transform {{
          Scale {{
            X: 1
            Y: 1
            Z: 1
          }}
        }}
        ParentId: {generate_id()}
        {self.children_to_string()}Collidable_v2 {{
          Value: "mc:ecollisionsetting:inheritfromparent"
        }}
        Visible_v2 {{
          Value: "mc:evisibilitysetting:inheritfromparent"
        }}
        CameraCollidable {{
          Value: "mc:ecollisionsetting:inheritfromparent"
        }}
        EditorIndicatorVisibility {{
          Value: "mc:eindicatorvisibility:visiblewhenselected"
        }}
        Folder {{
          IsGroup: true
        }}
      }}
      {self.all_objects_pbt()[:-2]}}}
    {self.object_assets_pbt()}
    Assets {{
      Id: 6942069420
      Name: "Basic Material"
      PlatformAssetType: 2
      PrimaryAsset {{
        AssetType: "MaterialAssetRef"
        AssetId: "mi_basic_pbr_material_001"
      }}
    }}
    PrimaryAssetId {{
      AssetType: "None"
      AssetId: "None"
    }}
  }}
  SerializationVersion: 92
}}"""
        return pbt


def open_file():
    global aesthetic_path, file_path, pure_path
    file_path = filedialog.askopenfilename()
    path_name = PurePath(file_path).name
    if len(path_name[:-4]) > 16:
        path_name = path_name[:12] + '...' + path_name[-7:]
    aesthetic_path.set(f"{path_name}")


def convert_file():
    global file_path
    if not file_path == '':
        root.withdraw()
        run(file_path)
    else:
        open_file()


optimize, texturize = tk.IntVar(value=1), tk.IntVar(value=0)
aesthetic_path, file_path, path_name = tk.StringVar(), '', ''
input_style = ttk.Style()
input_style.configure('TButton', font=('Helvetica', 10, 'bold'))
input_lbl = ttk.Label(root, textvariable=aesthetic_path, background='#d8d8d8', width=23, anchor=tk.CENTER, font=('Helvetica', 9, 'italic'))
input_btn = ttk.Button(root, text='Select triangulated .obj', width=22, style='TButton', command=open_file)
optimize_box = ttk.Checkbutton(root, text="Optimize object count", variable=optimize, onvalue=1, offvalue=0)
texturize_box = ttk.Checkbutton(root, text="Texturize using .mtl file", variable=texturize, onvalue=1, offvalue=0)
convert_btn = ttk.Button(root, text='Convert', width=22, style='TButton', command=convert_file)


def buttonize():
    root.geometry('164x123')  # set window geometry
    progress_bar['value'] = 0  # set progress bar to empty
    input_lbl.place(x=0, y=0)  # place labels and buttons
    input_btn.place(x=0, y=19)
    optimize_box.place(x=3, y=50)
    texturize_box.place(x=3, y=70)
    convert_btn.place(x=0, y=97)

buttonize()

def generate_id():
    global anti_conflict
    rando = randrange(10 ** 18, 10 ** 19)
    if not rando in anti_conflict:
        anti_conflict.append(rando)
        return f'{rando}'
    else:
        generate_id()


# Function given by Waffle and revised/commented by Zanth. See docs for details
def triangle(a, b, c):

    ab, ac, bc = np.subtract(b, a), np.subtract(c, a), np.subtract(c, b)  # vectors between the points

    # by comparing the lengths of the sides, we can determine the largest angle
    # remember: we want angle c to be the largest
    len_ab, len_ac, len_bc = np.linalg.norm(ab), np.linalg.norm(ac), np.linalg.norm(bc)

    # if angle a is the largest, swap c and a
    if len_bc > len_ab and len_bc > len_ac:
        c, a = a, c
        bc, ab = -ab, -bc
        len_bc, len_ab = len_ab, len_bc
        ac = -ac

    # if angle b is the largest, swap c and b
    elif len_ac > len_ab and len_ac > len_bc:
        c, b = b, c
        ac, ab = ab, ac
        len_ac, len_ab = len_ab, len_ac
        bc = -bc

    # if angle c is the largest, or there is an equilateral triangle...
    else:
        pass

    # calculates angle c to test if it's a right triangle
    ac_unit = np.divide(ac, np.linalg.norm(ac))
    bc_unit = np.divide(bc, np.linalg.norm(bc))
    dot_product = np.dot(ac_unit, bc_unit)
    angle_c = np.arccos(dot_product)

    # if angle c is a right angle if and only if the triangle is a right triangle
    if angle_c == np.pi / 2 and optimize.get() == 1:

        # position calculation - our triangles are corner-aligned wedges, so position is where the right angle occurs
        # which is always point c in our program
        position = c

        # scale calculation
        scale = np.divide([0.02, len_ac, len_bc], 100)

        # rotation calculation
        z = -bc_unit                            # z is the unit vector of -bc, aka -bc hat. Length vector of triangle
        y = -ac_unit                            # y is the unit vector of -ac, aka -ac hat. Width vector of triangle
        x = np.cross(y, z)                      # x is the cross product of x and y
        matrix = np.transpose([-x, -y, z])      # matrix is the rotation matrix of the triangle
        rotation = R.from_matrix(matrix).as_euler('xyz', degrees=True) * [-1, -1, 1]

        return position, None, scale, None, rotation, None

    z = np.divide(ab, len_ab)               # z is the unit vector of ab, aka ab hat
    l1 = np.multiply(np.dot(ac, z), z)      # l1 is the length vector of triangle_0
    l2 = np.subtract(l1, ab)                # l2 is the length vector of triangle_1
    p = np.subtract(ac, l1)                 # p is the width vector. This is the vector that splits the two triangles
    width = np.linalg.norm(p)               # width is the magnitude of p. It is the length of the shared side

    y = np.divide(p, width)                 # y is the unit vector of p, aka p hat
    x = np.cross(y, z)                      # x is the cross product of y and z

    # position calculation - our triangles are corner-aligned wedges, so position is where the right angle occurs
    # which is the same for both triangles, since they share the point where their right angles occur
    position_1 = position_2 = np.add(a, l1)

    # scale calculation
    scale_1, scale_2 = np.divide([0.02, width, np.linalg.norm(l1)], 100), np.divide([0.02, width, np.linalg.norm(l2)], 100)

    # Rotation calculation
    matrix_1, matrix_2 = np.transpose([x, -y, -z]), np.transpose([-x, -y, z])
    rotation_1, rotation_2 = R.from_matrix(matrix_1).as_euler('xyz', degrees=True) * [-1, -1, 1], \
                             R.from_matrix(matrix_2).as_euler('xyz', degrees=True) * [-1, -1, 1]

    return position_1, position_2, scale_1, scale_2, rotation_1, rotation_2


def run(path):
    entry_name = str(Path(splitext(path)[0])).split('\\')[-1:][0]
    parent = str(Path(path).parent)
    pbt_output = PBT(name=f'{entry_name}')

    # reset vertex, map, and output if they exist
    # read input and output files into memory
    uuid = str(uuid4()).split('-')[-1:][0]
    open(f'{parent}/{uuid}-vertex.txt', 'w').close(), open(f'{parent}/{uuid}-map.txt', 'w').close()
    open(f'{parent}/{entry_name}.pbt', 'w').close()
    vertex_file, map_file, texture_cords_file = open(f'{parent}/{uuid}-vertex.txt', 'a'), open(f'{parent}/{uuid}-map.txt', 'a'), open(f'{parent}/{uuid}-texture.txt', 'a')
    input_file, output_file, mtl_file = open(f'{path}', 'r'), open(f'{parent}/{entry_name}.pbt', 'a'), None
    input_lines = input_file.readlines()
    textures_by_index, textures = {}, {} #textures_by_index corresponds to the mat name of a group, textures is the actual texture data of a texture with the mat name being used as key.

    # extract vertices, face-maps, and groups from input .obj file
    object_number, g_count = 1, 0
    folders, group_names = [], []
    for line in input_lines:
        if line.startswith('v '):
            vertex_file.write(line[2:])
        elif line.startswith('g ') or line.startswith('o '):
            object_number += 1
            g_count += 1
            group_names.append(line[2:].lower().strip())
            folders.append(pbt_output.add_folder(f"{line[2:].title().strip()}"))
        elif line.startswith('vt '):
            texture_cords_file.write(line[3:])
        elif line.startswith('f '):
            map_file.write(f'{line[1:].strip()} {object_number - 1}\n')
        elif line.startswith('mtllib '):
            mtl_file = line[7:-1]
        elif line.startswith('usemtl '):
            textures_by_index[g_count - 1] = line[7:]

    if g_count == 0:
        folders.append(pbt_output.add_folder(f"Model"))
    vertex_file.close(), map_file.close(), texture_cords_file.close()

    # get vertices and face-maps by line
    vertices_by_line = [n.strip() for n in open(f'{parent}/{uuid}-vertex.txt', 'r').readlines()]
    face_maps_by_line = [n.strip() for n in open(f'{parent}/{uuid}-map.txt', 'r').readlines()]
    texture_cords_by_line = [n.strip() for n in open(f'{parent}/{uuid}-texture.txt', 'r').readlines()]

    if mtl_file is not None and texturize.get() == 1:
        mtl_raw_data = open(f'{parent}/{mtl_file}')
        mat_name = ""
        for line in mtl_raw_data.readlines():
            if line.startswith('newmtl '):
                mat_name = line[7:]
                textures[mat_name] = {}
            elif line.startswith('map_Kd '):
                if len(line[7:-1]) > 1:
                    path = line[7:-1]
                    if not isabs(path): #If the path isn't absolute it changes path to absolute
                        path = Path(f'{parent}/{line[7:-1]}')
                    texture = Image.open(path)
                    textures[mat_name][0] = texture
            elif line.startswith('Kd'):
                textures[mat_name][1] = [float(n) for n in line[3:].split()]

    input_btn.place_forget()
    input_lbl.place_forget()
    convert_btn.place_forget()
    optimize_box.place_forget()
    texturize_box.place_forget()
    root.deiconify()
    root.geometry('230x61')
    progress_bar.place(x=0, y=0)
    progress_lbl = ttk.Label(root, text=f'Generating {entry_name + ".pbt..."}', font=('Helvetica', 8))
    progress_lbl.place(x=0, y=23)
    progress_uuid = ttk.Label(root, text=f'UUID: {uuid}', font=('Helvetica', 8))
    progress_uuid.place(x=0, y=40)
    root.update()

    progress_bar['maximum'] = len(face_maps_by_line)

    mesh_index, current_group = 0, 0
    for triangle_map in face_maps_by_line:  # iterate through each face map
        a, b, c = [], [], []  # reset vectors to empty lists
        maps_gs = [s for s in findall(r'-?\d+\.?\d*/?\d*/?\d*', triangle_map)]
        group = 0 if int(maps_gs[len(maps_gs) - 1]) == 0 else int(maps_gs[len(maps_gs) - 1]) - 1 #Get group index
        if not current_group == group:
            mesh_index = 0
            current_group = group
        texture_name = None
        texture_image = None
        diffuse_color = [1,1,1] #Diffuse color, is multiplied by texture color for color. Solid color for entire material
        texture_color = [1,1,1] #Texture color, the color that is gotten from the texture image with the texture cords specified in the obj
        color = [0,0,0] #Final color
        texture_cords = []
        if group in textures_by_index and texturize.get() == 1:
            texture_name = textures_by_index[group]
            if 0 in textures[texture_name]:
                texture_image = textures[texture_name][0]
            if 1 in textures[texture_name]:
                diffuse_color = textures[texture_name][1]


        for vI, vertex in enumerate(triangle_map.split()[:-1]): # Loop through all the triangles in the face
            target_line = vertices_by_line[int(vertex.split('/')[0]) - 1] # Get the line that the v is on. The .split(/) is to get rid of unneeded info
            vertex_position = [float(n) for n in target_line.split(' ')] # Get the position in form [x,y,z]
            if vI == 0: a = vertex_position
            elif vI == 1: b = vertex_position
            elif vI == 2: c = vertex_position
            if len(vertex.split('/')) > 1 and texture_image and texturize.get() == 1:
                texture_cord = vertex.split('/')[1]
                if texture_cord != '':
                    cords = texture_cords_by_line[int(texture_cord) - 1].split()
                    cords[0] = max(1, floor(float(cords[0]) * texture_image.width) - 1)
                    cords[1] = max(1, floor(float(cords[1]) * texture_image.height) - 1)
                    texture_cords.append(cords)

        if len(texture_cords) > 0 and texturize.get() == 1:
            center = {}
            x1,x2,x3 = texture_cords[0][0], texture_cords[1][0], texture_cords[2][0]
            y1,y2,y3 = texture_cords[0][1], texture_cords[2][1], texture_cords[2][1]
            center[0] = round((x1 + x2 + x3) / 3, 2)
            center[1] = round((y1 + y2 + y3) / 3, 2)
            texture_color = [0,0,0]
            texture_color = np.add(texture_color, np.multiply(np.divide(texture_image.getpixel((center[0], center[1])), 255), 3)[:3]) #Get the color in center of the triangle, count it as half of the color.
            for cord in texture_cords:
                cord_color = np.divide(texture_image.getpixel((cord[0], cord[1]))[:3], 255)
                texture_color = np.add(texture_color, cord_color)
            texture_color = np.divide(texture_color, len(texture_cords) + 3) #Divide to get final texture color for this triangle between 0 and 1

        color = np.multiply(texture_color, diffuse_color) #Multiply the diffuse and texture colors



        core_a = [a[2], -a[0], a[1]] #Convert to Core positions
        core_b = [b[2], -b[0], b[1]]
        core_c = [c[2], -c[0], c[1]]

        position_one, position_two, scale_one, scale_two, rotation_one, rotation_two = triangle(core_a, core_b, core_c)
        progress_bar['value'] += 1
        root.update_idletasks()
        for position, scale, rotation in zip([position_one, position_two],
                                             [scale_one, scale_two],
                                             [rotation_one, rotation_two]):
            if position is not None and scale is not None and rotation is not None:
                mesh_index += 1
                child_name = "{0}.{1:04}".format(group_names[group] if g_count > 0 else 'mesh', mesh_index)
                folders[group].add_child(child_name, "sm_wedge_002", np.multiply(position, 10), rotation, np.multiply(scale, 10), None, color)
            else:
                continue

    progress_bar.place_forget()
    progress_lbl.place_forget()
    progress_uuid.place_forget()
    root.update()
    root.geometry('60x21')
    lbl = ttk.Label(root, text='wrapping up...', font=('Helvetica', 10, 'bold italic'))
    lbl.place(x=0, y=0)
    root.update()
    output_file.write(pbt_output.generate_pbt())
    remove(f'{parent}/{uuid}-vertex.txt'), remove(f'{parent}/{uuid}-map.txt'), remove(f'{parent}/{uuid}-texture.txt')
    input_file.close(), output_file.close()
    lbl.place_forget()
    aesthetic_path.set('')
    file_path = ''
    buttonize()


root.mainloop()
